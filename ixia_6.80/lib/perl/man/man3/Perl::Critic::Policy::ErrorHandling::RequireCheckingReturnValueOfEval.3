.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Perl::Critic::Policy::ErrorHandling::RequireCheckingReturnValueOfEval 3"
.TH Perl::Critic::Policy::ErrorHandling::RequireCheckingReturnValueOfEval 3 "2012-07-10" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Perl::Critic::Policy::ErrorHandling::RequireCheckingReturnValueOfEval \- You can't depend upon the value of "$@"/"$EVAL_ERROR" to tell whether an "eval" failed.
.SH "AFFILIATION"
.IX Header "AFFILIATION"
This Policy is part of the core Perl::Critic
distribution.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A common idiom in perl for dealing with possible errors is to use
\&\f(CW\*(C`eval\*(C'\fR followed by a check of \f(CW$@\fR/\f(CW$EVAL_ERROR\fR:
.PP
.Vb 6
\&    eval {
\&        ...
\&    };
\&    if ($EVAL_ERROR) {
\&        ...
\&    }
.Ve
.PP
There's a problem with this: the value of \f(CW$EVAL_ERROR\fR can change
between the end of the \f(CW\*(C`eval\*(C'\fR and the \f(CW\*(C`if\*(C'\fR statement.  The issue is
object destructors:
.PP
.Vb 1
\&    package Foo;
\&
\&    ...
\&
\&    sub DESTROY {
\&        ...
\&        eval { ... };
\&        ...
\&    }
\&
\&    package main;
\&
\&    eval {
\&        my $foo = Foo\->new();
\&        ...
\&    };
\&    if ($EVAL_ERROR) {
\&        ...
\&    }
.Ve
.PP
Assuming there are no other references to \f(CW$foo\fR created, when the
\&\f(CW\*(C`eval\*(C'\fR block in \f(CW\*(C`main\*(C'\fR is exited, \f(CW\*(C`Foo::DESTROY()\*(C'\fR will be invoked,
regardless of whether the \f(CW\*(C`eval\*(C'\fR finished normally or not.  If the
\&\f(CW\*(C`eval\*(C'\fR in \f(CW\*(C`main\*(C'\fR fails, but the \f(CW\*(C`eval\*(C'\fR in \f(CW\*(C`Foo::DESTROY()\*(C'\fR
succeeds, then \f(CW$EVAL_ERROR\fR will be empty by the time that the \f(CW\*(C`if\*(C'\fR
is executed.  Additional issues arise if you depend upon the exact
contents of \f(CW$EVAL_ERROR\fR and both \f(CW\*(C`eval\*(C'\fRs fail, because the
messages from both will be concatenated.
.PP
Even if there isn't an \f(CW\*(C`eval\*(C'\fR directly in the \f(CW\*(C`DESTROY()\*(C'\fR method
code, it may invoke code that does use \f(CW\*(C`eval\*(C'\fR or otherwise affects
\&\f(CW$EVAL_ERROR\fR.
.PP
The solution is to ensure that, upon normal exit, an \f(CW\*(C`eval\*(C'\fR returns a
true value and to test that value:
.PP
.Vb 2
\&    # Constructors are no problem.
\&    my $object = eval { Class\->new() };
\&
\&    # To cover the possiblity that an operation may correctly return a
\&    # false value, end the block with "1":
\&    if ( eval { something(); 1 } ) {
\&        ...
\&    }
\&
\&    eval {
\&        ...
\&        1;
\&    }
\&        or do {
\&            # Error handling here
\&        };
.Ve
.PP
Unfortunately, you can't use the \f(CW\*(C`defined\*(C'\fR function to test the
result; \f(CW\*(C`eval\*(C'\fR returns an empty string on failure.
.PP
Various modules have been written to take some of the pain out of
properly localizing and checking \f(CW$@\fR/\f(CW$EVAL_ERROR\fR. For example:
.PP
.Vb 7
\&    use Try::Tiny;
\&    try {
\&        ...
\&    } catch {
\&        # Error handling here;
\&        # The exception is in $_/$ARG, not $@/$EVAL_ERROR.
\&    };  # Note semicolon.
.Ve
.PP
\&\*(L"But we don't use \s-1\fIDESTROY\s0()\fR anywhere in our code!\*(R" you say.  That may
be the case, but do any of the third-party modules you use have them?
What about any you may use in the future or updated versions of the
ones you already use?
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
This Policy is not configurable except for the standard options.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See thread on perl5\-porters starting here:
<http://www.xray.mpe.mpg.de/mailing\-lists/perl5\-porters/2008\-06/msg00537.html>.
.PP
For a nice, easy, non-magical way of properly handling exceptions, see
Try::Tiny.
.SH "AUTHOR"
.IX Header "AUTHOR"
Elliot Shank \f(CW\*(C`<perl@galumph.com>\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2008\-2011 Elliot Shank.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  The full text of this license
can be found in the \s-1LICENSE\s0 file included with this module.
