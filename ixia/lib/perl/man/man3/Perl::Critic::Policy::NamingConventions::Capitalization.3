.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Perl::Critic::Policy::NamingConventions::Capitalization 3"
.TH Perl::Critic::Policy::NamingConventions::Capitalization 3 "2012-07-10" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Perl::Critic::Policy::NamingConventions::Capitalization \- Distinguish different program components by case.
.SH "AFFILIATION"
.IX Header "AFFILIATION"
This Policy is part of the core Perl::Critic distribution.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Conway recommends to distinguish different program components by case.
.PP
Normal subroutines, methods and variables are all in lower case.
.PP
.Vb 4
\&    my $foo;            # ok
\&    my $foo_bar;        # ok
\&    sub foo {}          # ok
\&    sub foo_bar {}      # ok
\&
\&    my $Foo;            # not ok
\&    my $foo_Bar;        # not ok
\&    sub Foo     {}      # not ok
\&    sub foo_Bar {}      # not ok
.Ve
.PP
Package and class names are capitalized.
.PP
.Vb 2
\&    package IO::Thing;     # ok
\&    package Web::FooBar    # ok
\&
\&    package foo;           # not ok
\&    package foo::Bar;      # not ok
.Ve
.PP
Constants are in all-caps.
.PP
.Vb 1
\&    Readonly::Scalar my $FOO = 42;  # ok
\&
\&    Readonly::Scalar my $foo = 42;  # not ok
.Ve
.PP
There are other opinions on the specifics, for example, in
perlstyle.  This
policy can be configured to match almost any style that you can think of.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
You can specify capitalization rules for the following things:
\&\f(CW\*(C`packages\*(C'\fR, \f(CW\*(C`subroutines\*(C'\fR, \f(CW\*(C`local_lexical_variables\*(C'\fR,
\&\f(CW\*(C`scoped_lexical_variables\*(C'\fR, \f(CW\*(C`file_lexical_variables\*(C'\fR,
\&\f(CW\*(C`global_variables\*(C'\fR, \f(CW\*(C`constants\*(C'\fR, and \f(CW\*(C`labels\*(C'\fR.
.PP
\&\f(CW\*(C`constants\*(C'\fR are things declared via constant or
Readonly.
.PP
.Vb 2
\&    use constant FOO => 193;
\&    Readonly::Array my @BAR => qw< a b c >;
.Ve
.PP
\&\f(CW\*(C`global_variables\*(C'\fR are anything declared using \f(CW\*(C`local\*(C'\fR, \f(CW\*(C`our\*(C'\fR, or
vars.  \f(CW\*(C`file_lexical_variables\*(C'\fR are variables declared at the
file scope.
.PP
\&\f(CW\*(C`scoped_lexical_variables\*(C'\fR are variables declared inside bare blocks
that are outside of any subroutines or other control structures; these
are usually created to limit scope of variables to a given subset of
subroutines.  E.g.
.PP
.Vb 1
\&    sub foo { ... }
\&
\&    {
\&        my $thingy;
\&
\&        sub bar { ... $thingy ... }
\&        sub baz { ... $thingy ... }
\&    }
.Ve
.PP
All other variable declarations are considered
\&\f(CW\*(C`local_lexical_variables\*(C'\fR.
.PP
Each of the \f(CW\*(C`packages\*(C'\fR, \f(CW\*(C`subroutines\*(C'\fR, \f(CW\*(C`local_lexical_variables\*(C'\fR,
\&\f(CW\*(C`scoped_lexical_variables\*(C'\fR, \f(CW\*(C`file_lexical_variables\*(C'\fR,
\&\f(CW\*(C`global_variables\*(C'\fR, \f(CW\*(C`constants\*(C'\fR, and \f(CW\*(C`labels\*(C'\fR options can be
specified as one of \f(CW\*(C`:single_case\*(C'\fR, \f(CW\*(C`:all_lower\*(C'\fR, \f(CW\*(C`:all_upper:\*(C'\fR,
\&\f(CW\*(C`:starts_with_lower\*(C'\fR, \f(CW\*(C`:starts_with_upper\*(C'\fR, or \f(CW\*(C`:no_restriction\*(C'\fR or
a regular expression; any value that does not start with a colon,
\&\f(CW\*(C`:\*(C'\fR, is considered to be a regular expression.  The \f(CW\*(C`:single_case\*(C'\fR
tag means a name can be all lower case or all upper case.  If a
regular expression is specified, it is surrounded by \f(CW\*(C`\eA\*(C'\fR and \f(CW\*(C`\ez\*(C'\fR.
.PP
\&\f(CW\*(C`packages\*(C'\fR defaults to \f(CW\*(C`:starts_with_upper\*(C'\fR.  \f(CW\*(C`subroutines\*(C'\fR,
\&\f(CW\*(C`local_lexical_variables\*(C'\fR, \f(CW\*(C`scoped_lexical_variables\*(C'\fR,
\&\f(CW\*(C`file_lexical_variables\*(C'\fR, and \f(CW\*(C`global_variables\*(C'\fR default to
\&\f(CW\*(C`:single_case\*(C'\fR.  And \f(CW\*(C`constants\*(C'\fR and \f(CW\*(C`labels\*(C'\fR default to
\&\f(CW\*(C`:all_upper\*(C'\fR.
.PP
There are corresponding \f(CW\*(C`package_exemptions\*(C'\fR,
\&\f(CW\*(C`subroutine_exemptions\*(C'\fR, \f(CW\*(C`local_lexical_variable_exemptions\*(C'\fR,
\&\f(CW\*(C`scoped_lexical_variable_exemptions\*(C'\fR,
\&\f(CW\*(C`file_lexical_variable_exemptions\*(C'\fR, \f(CW\*(C`global_variable_exemptions\*(C'\fR,
\&\f(CW\*(C`constant_exemptions\*(C'\fR, and \f(CW\*(C`label_exemptions\*(C'\fR options that are lists
of regular expressions to exempt from the corresponding capitalization
rule.  These values also end up being surrounded by \f(CW\*(C`\eA\*(C'\fR and \f(CW\*(C`\ez\*(C'\fR.
.PP
\&\f(CW\*(C`package_exemptions\*(C'\fR defaults to \f(CW\*(C`main\*(C'\fR.  \f(CW\*(C`global_variable_exemptions\*(C'\fR
defaults to
\&\f(CW\*(C`\e$VERSION @ISA @EXPORT(?:_OK)? %EXPORT_TAGS \e$AUTOLOAD %ENV %SIG \e$TODO\*(C'\fR.
\&\f(CW\*(C`subroutine_exemptions\*(C'\fR defaults to
\&\f(CW\*(C`AUTOLOAD BUILD BUILDARGS CLEAR CLOSE DELETE DEMOLISH DESTROY EXISTS EXTEND FETCH FETCHSIZE FIRSTKEY GETC NEXTKEY POP PRINT PRINTF PUSH READ READLINE SCALAR SHIFT SPLICE STORE STORESIZE TIEARRAY TIEHANDLE TIEHASH TIESCALAR UNSHIFT UNTIE WRITE\*(C'\fR
which should cover all the standard Perl subroutines plus those from
Moose.
.PP
For example, if you want all local variables to be in all lower-case
and global variables to start with \*(L"G_\*(R" and otherwise not contain
underscores, but exempt any variable with a name that contains
\&\*(L"\s-1THINGY\*(R",\s0 you could put the following in your \fI.perlcriticrc\fR:
.PP
.Vb 4
\&    [NamingConventions::Capitalization]
\&    local_lexical_variables = :all_lower
\&    global_variables = G_(?:(?!_)\ew)+
\&    global_variable_exemptions = .*THINGY.*
.Ve
.SH "TODO"
.IX Header "TODO"
Handle \f(CW\*(C`use vars\*(C'\fR.  Treat constant subroutines like constant
variables.  Handle bareword file handles.  There needs to be \*(L"schemes\*(R"
or ways of specifying \*(L"perlstyle\*(R" or \*(L"pbp\*(R".  Differentiate lexical
Readonly constants in scopes.
.SH "BUGS"
.IX Header "BUGS"
This policy won't catch problems with the declaration of \f(CW$y\fR below:
.PP
.Vb 3
\&    for (my $x = 3, my $y = 5; $x < 57; $x += 3) {
\&        ...
\&    }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Multiple people
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2008\-2011 Michael G Schwern.  All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  The full text of this license
can be found in the \s-1LICENSE\s0 file included with this module.
