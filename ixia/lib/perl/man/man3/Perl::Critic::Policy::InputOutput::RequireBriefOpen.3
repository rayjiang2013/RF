.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Perl::Critic::Policy::InputOutput::RequireBriefOpen 3"
.TH Perl::Critic::Policy::InputOutput::RequireBriefOpen 3 "2012-07-10" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Perl::Critic::Policy::InputOutput::RequireBriefOpen \- Close filehandles as soon as possible after opening them.
.SH "AFFILIATION"
.IX Header "AFFILIATION"
This Policy is part of the core Perl::Critic
distribution.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
One way that production systems fail unexpectedly is by running out of
filehandles.  Filehandles are a finite resource on every operating
system that I'm aware of, and running out of them is virtually
impossible to recover from.  The solution is to not run out in the
first place.  What causes programs to run out of filehandles?
Usually, it's leaks: you open a filehandle and forget to close it, or
just wait a really long time before closing it.
.PP
This problem is rarely exposed by test systems, because the tests
rarely run long enough or have enough load to hit the filehandle
limit.  So, the best way to avoid the problem is 1) always close all
filehandles that you open and 2) close them as soon as is practical.
.PP
This policy takes note of calls to \f(CW\*(C`open()\*(C'\fR where there is no
matching \f(CW\*(C`close()\*(C'\fR call within \f(CW\*(C`N\*(C'\fR lines of code.  If you really
need to do a lot of processing on an open filehandle, then you can
move that processing to another method like this:
.PP
.Vb 10
\&    sub process_data_file {
\&        my ($self, $filename) = @_;
\&        open my $fh, \*(Aq<\*(Aq, $filename
\&            or croak \*(AqFailed to read datafile \*(Aq .  $filename . \*(Aq; \*(Aq . $OS_ERROR;
\&        $self\->_parse_input_data($fh);
\&        close $fh;
\&        return;
\&    }
\&    sub _parse_input_data {
\&        my ($self, $fh) = @_;
\&        while (my $line = <$fh>) {
\&            ...
\&        }
\&        return;
\&    }
.Ve
.PP
As a special case, this policy also allows code to return the
filehandle after the \f(CW\*(C`open\*(C'\fR instead of closing it.  Just like the
close, however, that \f(CW\*(C`return\*(C'\fR has to be within the right number of
lines.  From there, you're on your own to figure out whether the code
is promptly closing the filehandle.
.PP
The \s-1STDIN, STDOUT,\s0 and \s-1STDERR\s0 handles are exempt from this policy.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
This policy allows \f(CW\*(C`close()\*(C'\fR invocations to be up to \f(CW\*(C`N\*(C'\fR lines after
their corresponding \f(CW\*(C`open()\*(C'\fR calls, where \f(CW\*(C`N\*(C'\fR defaults to 9.  You
can override this to set it to a different number with the \f(CW\*(C`lines\*(C'\fR
setting.  To do this, put entries in a \fI.perlcriticrc\fR file like
this:
.PP
.Vb 2
\&  [InputOutput::RequireBriefOpen]
\&  lines = 5
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
.ie n .SS """IO::File\->new"""
.el .SS "\f(CWIO::File\->new\fP"
.IX Subsection "IO::File->new"
This policy only looks for explicit \f(CW\*(C`open\*(C'\fR calls.  It does not detect
calls to \f(CW\*(C`CORE::open\*(C'\fR or \f(CW\*(C`IO::File\->new\*(C'\fR or the like.
.SS "Is it the right lexical?"
.IX Subsection "Is it the right lexical?"
We don't currently check for redeclared filehandles.  So the following
code is false negative, for example, because the outer scoped
filehandle is not closed:
.PP
.Vb 5
\&    open my $fh, \*(Aq<\*(Aq, $file1 or croak;
\&    if (open my $fh, \*(Aq<\*(Aq, $file2) {
\&        print <$fh>;
\&        close $fh;
\&    }
.Ve
.PP
This is a contrived example, but it isn't uncommon for people to use
\&\f(CW$fh\fR for the name of the filehandle every time.  Perhaps it's time
to think of better variable names...
.SH "CREDITS"
.IX Header "CREDITS"
Initial development of this policy was supported by a grant from the
Perl Foundation.
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Dolan <cdolan@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2007\-2011 Chris Dolan.  Many rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  The full text of this license
can be found in the \s-1LICENSE\s0 file included with this module
